{"version":3,"sources":["components/Coin/Coin.js","engine/rules.js","engine/gameHelper.js","engine/moveHelper.js","components/ScoreBoard/ScoreBoard.js","components/Game/Game.js","engine/score.js","index.js"],"names":["Coin","color","className","coinNotPlaced","coin","isPlaced","isNextCoinPlacedAndDoesNotHaveSameColor","inPlayColor","isActiveColorCoin","leftSideCoinsValidation","coins","position","replaceableCoins","loopEndCondition","endDistance","Math","floor","getDistanceForLeftSideCoinsValidation","index","push","getReplaceableCoins","inPlayCoin","ceil","rightSideCoinsValidation","round","upsideCoinsValidation","downsideCoinsValidation","leftUpCrossCoinsValidation","rightUpCrossCoinsValidation","leftDownCrossCoinsValidation","rightDownCrossCoinsValidation","getUpdatedBoard","update","forEach","colors","getPossibleMoves","possibleMoves","Object","keys","e","length","isEmptyAndPossibleMove","ScoreBoard","black","white","currentColor","Game","useState","board","Array","fill","i","createBoard","setBoard","activePlayer","setActivePlayer","setPossibleMoves","score","setScore","useEffect","getScore","placeCoin","id","isValidMove","map","initial","createId","onClick","bind","key","includes","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.1796b061.chunk.js","sourcesContent":["import React from \"react\";\n\nconst Coin = ({ color }) => {\n  return <div className={`coin ${color}`}></div>;\n};\n\nexport default Coin;\n","const MAX_ROW_COUNT = 8;\nconst MAX_CELL_COUNT = 64;\nconst RIGHT_SIDE_COIN_DIFFERENCE = 7;\nconst LEFT_COIN_DIFFERENCE = 9;\n\nconst coinNotPlaced = coin => !coin.isPlaced;\n\nconst isNextCoinPlacedAndDoesNotHaveSameColor = (coin, inPlayColor) => {\n  return coin.isPlaced && coin.color !== inPlayColor;\n};\n\nconst isActiveColorCoin = (coin, inPlayColor) => {\n  return coin.color === inPlayColor;\n};\n\nconst rightSideCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance =\n    Math.ceil(position / MAX_ROW_COUNT) * MAX_ROW_COUNT - position;\n  const replaceableCoins = [];\n  for (let index = position + 1; index <= position + endDistance; index++) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst getDistanceForLeftSideCoinsValidation = position => {\n  let endDistance =\n    position - Math.floor(position / MAX_ROW_COUNT) * MAX_ROW_COUNT;\n  endDistance = endDistance === 0 ? MAX_ROW_COUNT : endDistance;\n  return endDistance;\n};\n\nconst leftSideCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = getDistanceForLeftSideCoinsValidation(position);\n  const replaceableCoins = [];\n  const loopEndCondition = position - endDistance - 1;\n  for (\n    let index = position - 1;\n    index > loopEndCondition && index > 0;\n    index--\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst upsideCoinsValidation = (coins, position, inPlayColor) => {\n  let endDistance = Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position - MAX_ROW_COUNT;\n    index > 0;\n    index -= MAX_ROW_COUNT\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst downsideCoinsValidation = (coins, position, inPlayColor) => {\n  let endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position + MAX_ROW_COUNT;\n    index <= MAX_CELL_COUNT;\n    index += MAX_ROW_COUNT\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst leftUpCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = Math.round(position / MAX_ROW_COUNT) - 1;\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position - LEFT_COIN_DIFFERENCE;\n    index > 0;\n    index -= LEFT_COIN_DIFFERENCE\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst rightUpCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = Math.floor(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position - RIGHT_SIDE_COIN_DIFFERENCE;\n    index > 0;\n    index -= RIGHT_SIDE_COIN_DIFFERENCE\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst leftDownCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position + RIGHT_SIDE_COIN_DIFFERENCE;\n    index <= MAX_CELL_COUNT;\n    index += RIGHT_SIDE_COIN_DIFFERENCE\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst rightDownCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position + LEFT_COIN_DIFFERENCE;\n    index <= MAX_CELL_COUNT;\n    index += LEFT_COIN_DIFFERENCE\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst getReplaceableCoins = (coins, inPlayCoin, color) => {\n  const inPlayColor = color || inPlayCoin.color;\n  const position = inPlayCoin.position;\n  const replaceableCoins = [\n    ...rightSideCoinsValidation(coins, position, inPlayColor),\n    ...leftSideCoinsValidation(coins, position, inPlayColor),\n    ...upsideCoinsValidation(coins, position, inPlayColor),\n    ...downsideCoinsValidation(coins, position, inPlayColor),\n    ...leftUpCrossCoinsValidation(coins, position, inPlayColor),\n    ...rightUpCrossCoinsValidation(coins, position, inPlayColor),\n    ...leftDownCrossCoinsValidation(coins, position, inPlayColor),\n    ...rightDownCrossCoinsValidation(coins, position, inPlayColor)\n  ];\n  return replaceableCoins;\n};\n\nconst getUpdatedBoard = (coins, inPlayCoin) => {\n  const replaceableCoins = getReplaceableCoins(coins, inPlayCoin);\n\n  const inPlayColor = inPlayCoin.color;\n  const update = { ...coins };\n  replaceableCoins.forEach(index => {\n    update[index].color = inPlayColor === \"black\" ? \"black\" : \"white\";\n  });\n  return update;\n};\n\nexport {\n  getUpdatedBoard,\n  rightSideCoinsValidation,\n  leftSideCoinsValidation,\n  upsideCoinsValidation,\n  downsideCoinsValidation,\n  leftUpCrossCoinsValidation,\n  rightUpCrossCoinsValidation,\n  leftDownCrossCoinsValidation,\n  rightDownCrossCoinsValidation,\n  getReplaceableCoins\n};\n","const createBoard = () => {\n  const board = {};\n  new Array(64).fill(1).forEach((e, i) => {\n    board[i + 1] = {\n      isPlaced: false,\n      color: null,\n      position: i + 1\n    };\n  });\n  board[28].isPlaced = true;\n  board[28].color = \"white\";\n\n  board[29].isPlaced = true;\n  board[29].color = \"black\";\n\n  board[36].isPlaced = true;\n  board[36].color = \"black\";\n\n  board[37].isPlaced = true;\n  board[37].color = \"white\";\n\n  return board;\n};\n\nconst colors = [\"white\", \"black\"];\n\nconst createId = (initial, i) => initial * 8 + i + 1;\n\nexport { colors, createBoard, createId };\n","import { getReplaceableCoins } from \"./rules\";\n\nconst isValidMove = (coins, inPlayCoin, color) => {\n  if (inPlayCoin.isPlaced) return false;\n  const replaceableCoins = getReplaceableCoins(coins, inPlayCoin, color);\n  return replaceableCoins.length > 0;\n};\n\nconst isEmptyAndPossibleMove = (coins, coin, color) => {\n  return getReplaceableCoins(coins, coin, color).length && !coin.isPlaced;\n};\n\nconst getPossibleMoves = (coins, color) => {\n  const possibleMoves = [];\n  Object.keys(coins).forEach(e => {\n    if (isEmptyAndPossibleMove(coins, coins[e], color)) {\n      possibleMoves.push(+e);\n    }\n  });\n  return possibleMoves;\n};\n\nexport { isValidMove, getPossibleMoves };\n","import React from \"react\";\nimport Coin from \"../Coin/Coin\";\n\nconst ScoreBoard = ({ black, white, currentColor }) => {\n  return (\n    <div className=\"score-board\">\n      <div className=\"score-container\">\n        <Coin color=\"black\" />\n        <span className=\"score\">{black}</span>\n      </div>\n      <Coin color={currentColor} />\n      <div className=\"score-container\">\n        <Coin color=\"white\" />\n        <span className=\"score\">{white}</span>\n      </div>\n    </div>\n  );\n};\n\nexport default ScoreBoard;\n","import React, { useState, useEffect } from \"react\";\nimport Coin from \"../Coin/Coin\";\nimport { getUpdatedBoard } from \"../../engine/rules\";\nimport { createBoard, createId, colors } from \"../../engine/gameHelper\";\nimport { getPossibleMoves, isValidMove } from \"../../engine/moveHelper\";\nimport ScoreBoard from \"../ScoreBoard/ScoreBoard\";\nimport { getScore } from \"../../engine/score\";\n\nconst Game = () => {\n  const [board, setBoard] = useState(createBoard());\n  const [activePlayer, setActivePlayer] = useState(0);\n  const [possibleMoves, setPossibleMoves] = useState([]);\n  const [score, setScore] = useState({ black: 2, white: 2 });\n\n  useEffect(() => {\n    setPossibleMoves(getPossibleMoves(board, colors[activePlayer]));\n    setScore(getScore(board));\n  }, [board, activePlayer]);\n\n  const updateActivePlayer = () => {\n    const update = 1 - activePlayer;\n    setActivePlayer(update);\n  };\n\n  const placeCoin = (id, color) => {\n    const update = { ...board };\n    if (!isValidMove(update, update[id], color)) return;\n\n    update[id] = { ...update[id], isPlaced: true, color };\n    setBoard(update);\n    getUpdatedBoard(update, update[id]);\n    updateActivePlayer();\n  };\n\n  const createRow = initial => {\n    return new Array(8).fill(0).map((e, i) => {\n      const id = createId(initial, i);\n      return (\n        <div\n          onClick={placeCoin.bind(null, id, colors[activePlayer])}\n          id={id}\n          key={id}\n          className={`box `}\n        >\n          {possibleMoves.includes(id) && <Coin color=\"empty\" />}\n          {board[id].isPlaced && <Coin color={board[id].color} />}\n        </div>\n      );\n    });\n  };\n\n  return (\n    <div>\n      <ScoreBoard\n        black={score.black}\n        white={score.white}\n        currentColor={colors[activePlayer]}\n      />\n      <div className=\"board\">\n        {new Array(8).fill(0).map((e, i) => {\n          return <div className=\"row\">{createRow(i)}</div>;\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default Game;\n","const getScore = coins => {\n  const score = { white: 0, black: 0 };\n  Object.keys(coins).forEach(coin => {\n    if (coins[coin].color === \"white\") score.white++;\n    if (coins[coin].color === \"black\") score.black++;\n  });\n  return score;\n};\n\nexport { getScore };\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Game from \"./components/Game/Game\";\n\nReactDOM.render(<Game />, document.getElementById(\"root\"));\n"],"sourceRoot":""}