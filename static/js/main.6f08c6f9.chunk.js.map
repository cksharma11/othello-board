{"version":3,"sources":["Coin/Coin.js","Game/rules.js","Game/gameHelper.js","Game/Game.js","index.js"],"names":["Coin","color","className","coinNotPlaced","coin","isPlaced","isNextCoinPlacedAndDoesNotHaveSameColor","activeColor","isActiveColorCoin","leftSideCoinsValidation","coins","position","replaceableCoins","loopEndCondition","distance","Math","floor","getDistanceForLeftSideCoinsValidation","index","push","rulesValidator","currentlyPlacedCoin","ceil","rightSideCoinsValidation","round","upsideCoinsValidation","downsideCoinsValidation","leftUpCrossCoinsValidation","rightUpCrossCoinsValidation","leftDownCrossCoinsValidation","rightDownCrossCoinsValidation","update","forEach","colors","Game","useState","board","Array","fill","e","i","createBoard","setBoard","activePlayer","setActivePlayer","placeCoin","id","map","initial","createId","onClick","bind","key","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6f08c6f9.chunk.js","sourcesContent":["import React from 'react';\n\nconst Coin = ({ color }) => {\n  return <div className={`coin ${color}`}></div>\n};\n\nexport default Coin","const MAX_ROW_COUNT = 8;\nconst MAX_CELL_COUNT = 64;\nconst RIGHT_SIDE_COIN_DIFFERENCE = 7;\nconst LEFT_COIN_DIFFERENCE = 9;\n\nconst coinNotPlaced = (coin) => !coin.isPlaced;\n\nconst isNextCoinPlacedAndDoesNotHaveSameColor = (coin, activeColor) => {\n  return coin.isPlaced && coin.color !== activeColor;\n}\n\nconst isActiveColorCoin = (coin, activeColor) => {\n  return coin.color === activeColor;\n}\n\nconst rightSideCoinsValidation = (coins, position, activeColor) => {\n  const distance = Math.ceil(position / MAX_ROW_COUNT) * MAX_ROW_COUNT - position;\n  const replaceableCoins = [];\n  for (let index = position + 1; index <= position + distance; index++) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], activeColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], activeColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst getDistanceForLeftSideCoinsValidation = (position) => {\n  let distance = position - Math.floor(position / MAX_ROW_COUNT) * MAX_ROW_COUNT;\n  distance = distance === 0 ? MAX_ROW_COUNT : distance;\n  return distance;\n}\n\nconst leftSideCoinsValidation = (coins, position, activeColor) => {\n  const distance = getDistanceForLeftSideCoinsValidation(position);\n  const replaceableCoins = [];\n  const loopEndCondition = position - distance - 1;\n  for (let index = position - 1; index > loopEndCondition && index > 0; index--) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], activeColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], activeColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst upsideCoinsValidation = (coins, position, activeColor) => {\n  let distance = Math.round(position / MAX_ROW_COUNT);\n  if (distance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position - MAX_ROW_COUNT; index > 0; index -= MAX_ROW_COUNT) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], activeColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], activeColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst downsideCoinsValidation = (coins, position, activeColor) => {\n  let distance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (distance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position + MAX_ROW_COUNT; index <= MAX_CELL_COUNT; index += MAX_ROW_COUNT) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], activeColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], activeColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\n\nconst leftUpCrossCoinsValidation = (coins, position, activeColor) => {\n  const distance = Math.round(position / MAX_ROW_COUNT) - 1;\n  if (distance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position - LEFT_COIN_DIFFERENCE; index > 0; index -= LEFT_COIN_DIFFERENCE) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], activeColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], activeColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst rightUpCrossCoinsValidation = (coins, position, activeColor) => {\n  const distance = Math.floor(position / MAX_ROW_COUNT);\n  if (distance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position - RIGHT_SIDE_COIN_DIFFERENCE; index > 0; index -= RIGHT_SIDE_COIN_DIFFERENCE) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], activeColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], activeColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst leftDownCrossCoinsValidation = (coins, position, activeColor) => {\n  const distance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (distance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position + RIGHT_SIDE_COIN_DIFFERENCE; index <= MAX_CELL_COUNT ; index += RIGHT_SIDE_COIN_DIFFERENCE) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], activeColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], activeColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst rightDownCrossCoinsValidation = (coins, position, activeColor) => {\n  const distance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (distance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position + LEFT_COIN_DIFFERENCE; index <= MAX_CELL_COUNT; index += LEFT_COIN_DIFFERENCE) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], activeColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], activeColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst rulesValidator = (coins, currentlyPlacedCoin) => {\n  const activeColor = currentlyPlacedCoin.color;\n  const position = currentlyPlacedCoin.position;\n\n  const replaceableCoins = [\n    ...rightSideCoinsValidation(coins, position, activeColor),\n    ...leftSideCoinsValidation(coins, position, activeColor),\n    ...upsideCoinsValidation(coins, position, activeColor),\n    ...downsideCoinsValidation(coins, position, activeColor),\n    ...leftUpCrossCoinsValidation(coins, position, activeColor),\n    ...rightUpCrossCoinsValidation(coins, position, activeColor),\n    ...leftDownCrossCoinsValidation(coins, position, activeColor),\n    ...rightDownCrossCoinsValidation(coins, position, activeColor),\n  ];\n\n  const update = { ...coins };\n  replaceableCoins.forEach(index => {\n    update[index].color = activeColor === 'black' ? 'black' : 'white';\n  })\n  return update;\n}\n\nexport { \n  rulesValidator, \n  rightSideCoinsValidation, \n  leftSideCoinsValidation, \n  upsideCoinsValidation,\n  downsideCoinsValidation,\n  leftUpCrossCoinsValidation,\n  rightUpCrossCoinsValidation,\n  leftDownCrossCoinsValidation,\n  rightDownCrossCoinsValidation\n};","const createBoard = () => {\n  const board = {}\n  new Array(64).fill(1).forEach((e, i) => {\n      board[i + 1] = {\n        isPlaced: false,\n        color: null,\n        position: i + 1\n      }\n  })\n  board[28].isPlaced = true;\n  board[28].color = \"white\";\n\n  board[29].isPlaced = true;\n  board[29].color = \"black\";\n\n  board[36].isPlaced = true;\n  board[36].color = \"black\";\n\n  board[37].isPlaced = true;\n  board[37].color = \"white\";\n  \n  return board;\n}\n\nconst colors = [\"white\", \"black\"];\n\nconst createId = (initial, i) => initial * 8 + i + 1;\n\nexport { colors, createBoard, createId };","import React, {useState} from 'react';\nimport Coin from '../Coin/Coin';\nimport { rulesValidator } from './rules';\nimport { createBoard, createId, colors } from './gameHelper';\n\nconst Game = () => {\n  const [board, setBoard] = useState(createBoard());\n  const [activePlayer, setActivePlayer] = useState(0);\n\n  const updateActivePlayer = () => {\n    const update = 1 - activePlayer;\n    setActivePlayer(update);\n  }\n\n  const placeCoin = (id, color) => {\n    if (board[id].isPlaced) return;\n    const update = { ...board };\n    update[id] = { ...update[id], isPlaced: true, color };\n    setBoard(update);\n    rulesValidator(update, update[id]);\n    updateActivePlayer();\n  }\n\n  const createRow = (initial) => {\n    return (\n      new Array(8).fill(0).map((e, i) => {\n        const id = createId(initial, i);\n        return (\n          <div\n            onClick={placeCoin.bind(null, id, colors[activePlayer])}\n            id={id}\n            key={id}\n            className=\"box\"\n          >\n            {board[id].isPlaced && <Coin color={board[id].color}/> }\n            </div>\n        )\n      })\n    )\n  }\n\n  return (\n    <div className=\"board\">\n      {new Array(8).fill(0).map((e, i) => {\n        return <div className=\"row\">{createRow(i)}</div>\n      })}\n    </div>\n  )\n}\n  \nexport default Game;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Game from './Game/Game';\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}