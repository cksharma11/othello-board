{"version":3,"sources":["components/Coin/Coin.js","engine/rules.js","engine/gameHelper.js","engine/moveHelper.js","components/ScoreBoard/ScoreBoard.js","components/Header/Header.js","components/RestartButton/RestartButton.js","components/Game/Game.js","engine/score.js","serviceWorker.js","index.js"],"names":["Coin","color","className","coinNotPlaced","coin","isPlaced","isNextCoinPlacedAndDoesNotHaveSameColor","inPlayColor","isActiveColorCoin","leftSideCoinsValidation","coins","position","replaceableCoins","loopEndCondition","endDistance","Math","floor","getDistanceForLeftSideCoinsValidation","index","push","getReplaceableCoins","inPlayCoin","ceil","rightSideCoinsValidation","round","upsideCoinsValidation","downsideCoinsValidation","leftUpCrossCoinsValidation","rightUpCrossCoinsValidation","leftDownCrossCoinsValidation","rightDownCrossCoinsValidation","getUpdatedBoard","update","forEach","createBoard","board","Array","fill","e","i","colors","getPossibleMoves","possibleMoves","Object","keys","length","isEmptyAndPossibleMove","ScoreBoard","black","white","currentColor","Header","RestartButton","onRestart","onClick","Game","useState","setBoard","activePlayer","setActivePlayer","setPossibleMoves","score","setScore","useEffect","getScore","placeCoin","id","isValidMove","map","initial","createId","bind","key","includes","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","render","document","getElementById","URL","process","href","origin","addEventListener","fetch","response","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.d22de4d3.chunk.js","sourcesContent":["import React from \"react\";\n\nconst Coin = ({ color }) => {\n  return <div className={`coin ${color}`}></div>;\n};\n\nexport default Coin;\n","const MAX_ROW_COUNT = 8;\nconst MAX_CELL_COUNT = 64;\nconst RIGHT_SIDE_COIN_DIFFERENCE = 7;\nconst LEFT_COIN_DIFFERENCE = 9;\n\nconst coinNotPlaced = coin => !coin.isPlaced;\n\nconst isNextCoinPlacedAndDoesNotHaveSameColor = (coin, inPlayColor) => {\n  return coin.isPlaced && coin.color !== inPlayColor;\n};\n\nconst isActiveColorCoin = (coin, inPlayColor) => {\n  return coin.color === inPlayColor;\n};\n\nconst rightSideCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance =\n    Math.ceil(position / MAX_ROW_COUNT) * MAX_ROW_COUNT - position;\n  const replaceableCoins = [];\n  for (let index = position + 1; index <= position + endDistance; index++) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst getDistanceForLeftSideCoinsValidation = position => {\n  let endDistance =\n    position - Math.floor(position / MAX_ROW_COUNT) * MAX_ROW_COUNT;\n  endDistance = endDistance === 0 ? MAX_ROW_COUNT : endDistance;\n  return endDistance;\n};\n\nconst leftSideCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = getDistanceForLeftSideCoinsValidation(position);\n  const replaceableCoins = [];\n  const loopEndCondition = position - endDistance - 1;\n  for (\n    let index = position - 1;\n    index > loopEndCondition && index > 0;\n    index--\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst upsideCoinsValidation = (coins, position, inPlayColor) => {\n  let endDistance = Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position - MAX_ROW_COUNT;\n    index > 0;\n    index -= MAX_ROW_COUNT\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst downsideCoinsValidation = (coins, position, inPlayColor) => {\n  let endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position + MAX_ROW_COUNT;\n    index <= MAX_CELL_COUNT;\n    index += MAX_ROW_COUNT\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst leftUpCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = Math.round(position / MAX_ROW_COUNT) - 1;\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position - LEFT_COIN_DIFFERENCE;\n    index > 0;\n    index -= LEFT_COIN_DIFFERENCE\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst rightUpCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = Math.floor(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position - RIGHT_SIDE_COIN_DIFFERENCE;\n    index > 0;\n    index -= RIGHT_SIDE_COIN_DIFFERENCE\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst leftDownCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position + RIGHT_SIDE_COIN_DIFFERENCE;\n    index <= MAX_CELL_COUNT;\n    index += RIGHT_SIDE_COIN_DIFFERENCE\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst rightDownCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (\n    let index = position + LEFT_COIN_DIFFERENCE;\n    index <= MAX_CELL_COUNT;\n    index += LEFT_COIN_DIFFERENCE\n  ) {\n    if (coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n};\n\nconst getReplaceableCoins = (coins, inPlayCoin, color) => {\n  const inPlayColor = color || inPlayCoin.color;\n  const position = inPlayCoin.position;\n  const replaceableCoins = [\n    ...rightSideCoinsValidation(coins, position, inPlayColor),\n    ...leftSideCoinsValidation(coins, position, inPlayColor),\n    ...upsideCoinsValidation(coins, position, inPlayColor),\n    ...downsideCoinsValidation(coins, position, inPlayColor),\n    ...leftUpCrossCoinsValidation(coins, position, inPlayColor),\n    ...rightUpCrossCoinsValidation(coins, position, inPlayColor),\n    ...leftDownCrossCoinsValidation(coins, position, inPlayColor),\n    ...rightDownCrossCoinsValidation(coins, position, inPlayColor)\n  ];\n  return replaceableCoins;\n};\n\nconst getUpdatedBoard = (coins, inPlayCoin) => {\n  const replaceableCoins = getReplaceableCoins(coins, inPlayCoin);\n\n  const inPlayColor = inPlayCoin.color;\n  const update = { ...coins };\n  replaceableCoins.forEach(index => {\n    update[index].color = inPlayColor === \"black\" ? \"black\" : \"white\";\n  });\n  return update;\n};\n\nexport {\n  getUpdatedBoard,\n  rightSideCoinsValidation,\n  leftSideCoinsValidation,\n  upsideCoinsValidation,\n  downsideCoinsValidation,\n  leftUpCrossCoinsValidation,\n  rightUpCrossCoinsValidation,\n  leftDownCrossCoinsValidation,\n  rightDownCrossCoinsValidation,\n  getReplaceableCoins\n};\n","const createBoard = () => {\n  const board = {};\n  new Array(64).fill(1).forEach((e, i) => {\n    board[i + 1] = {\n      isPlaced: false,\n      color: null,\n      position: i + 1\n    };\n  });\n  board[28].isPlaced = true;\n  board[28].color = \"white\";\n\n  board[29].isPlaced = true;\n  board[29].color = \"black\";\n\n  board[36].isPlaced = true;\n  board[36].color = \"black\";\n\n  board[37].isPlaced = true;\n  board[37].color = \"white\";\n\n  return board;\n};\n\nconst colors = [\"white\", \"black\"];\n\nconst createId = (initial, i) => initial * 8 + i + 1;\n\nexport { colors, createBoard, createId };\n","import { getReplaceableCoins } from \"./rules\";\n\nconst isValidMove = (coins, inPlayCoin, color) => {\n  if (inPlayCoin.isPlaced) return false;\n  const replaceableCoins = getReplaceableCoins(coins, inPlayCoin, color);\n  return replaceableCoins.length > 0;\n};\n\nconst isEmptyAndPossibleMove = (coins, coin, color) => {\n  return getReplaceableCoins(coins, coin, color).length && !coin.isPlaced;\n};\n\nconst getPossibleMoves = (coins, color) => {\n  const possibleMoves = [];\n  Object.keys(coins).forEach(e => {\n    if (isEmptyAndPossibleMove(coins, coins[e], color)) {\n      possibleMoves.push(+e);\n    }\n  });\n  return possibleMoves;\n};\n\nexport { isValidMove, getPossibleMoves };\n","import React from \"react\";\nimport Coin from \"../Coin/Coin\";\n\nconst ScoreBoard = ({ black, white, currentColor }) => {\n  return (\n    <div className=\"score-board\">\n      <div className=\"score-container\">\n        <Coin color=\"black\" />\n        <span className=\"score\">{black}</span>\n      </div>\n      <Coin color={currentColor} />\n      <div className=\"score-container\">\n        <Coin color=\"white\" />\n        <span className=\"score\">{white}</span>\n      </div>\n    </div>\n  );\n};\n\nexport default ScoreBoard;\n","import React from \"react\";\n\nconst Header = () => {\n  return <h1 className=\"header\">OTHELLO</h1>;\n};\n\nexport default Header;\n","import React from \"react\";\n\nconst RestartButton = ({ onRestart }) => {\n  return (\n    <div className=\"restart-button-container\">\n      <button className=\"restart-button\" onClick={onRestart}>\n        Restart\n      </button>\n    </div>\n  );\n};\n\nexport default RestartButton;\n","import React, { useState, useEffect } from \"react\";\nimport Coin from \"../Coin/Coin\";\nimport { getUpdatedBoard } from \"../../engine/rules\";\nimport { createBoard, createId, colors } from \"../../engine/gameHelper\";\nimport { getPossibleMoves, isValidMove } from \"../../engine/moveHelper\";\nimport ScoreBoard from \"../ScoreBoard/ScoreBoard\";\nimport { getScore } from \"../../engine/score\";\nimport Header from \"../Header/Header\";\nimport RestartButton from \"../RestartButton/RestartButton\";\n\nconst Game = () => {\n  const [board, setBoard] = useState(createBoard());\n  const [activePlayer, setActivePlayer] = useState(0);\n  const [possibleMoves, setPossibleMoves] = useState([]);\n  const [score, setScore] = useState({ black: 2, white: 2 });\n\n  useEffect(() => {\n    setPossibleMoves(getPossibleMoves(board, colors[activePlayer]));\n    setScore(getScore(board));\n  }, [board, activePlayer]);\n\n  const updateActivePlayer = () => {\n    const update = 1 - activePlayer;\n    setActivePlayer(update);\n  };\n\n  const placeCoin = (id, color) => {\n    const update = { ...board };\n    if (!isValidMove(update, update[id], color)) return;\n\n    update[id] = { ...update[id], isPlaced: true, color };\n    setBoard(update);\n    getUpdatedBoard(update, update[id]);\n    updateActivePlayer();\n  };\n\n  const handleRestart = () => {\n    setBoard(createBoard());\n    setScore({ black: 2, white: 2 });\n    setActivePlayer(0);\n    setPossibleMoves([]);\n  };\n\n  const createRow = initial => {\n    return new Array(8).fill(0).map((e, i) => {\n      const id = createId(initial, i);\n      return (\n        <div\n          onClick={placeCoin.bind(null, id, colors[activePlayer])}\n          id={id}\n          key={id}\n          className={`box `}\n        >\n          {possibleMoves.includes(id) && <Coin color=\"empty\" />}\n          {board[id].isPlaced && <Coin color={board[id].color} />}\n        </div>\n      );\n    });\n  };\n\n  return (\n    <div>\n      <Header />\n      <ScoreBoard\n        black={score.black}\n        white={score.white}\n        currentColor={colors[activePlayer]}\n      />\n      <div className=\"board\">\n        {new Array(8).fill(0).map((e, i) => {\n          return <div className=\"row\">{createRow(i)}</div>;\n        })}\n      </div>\n      <RestartButton onRestart={handleRestart} />\n    </div>\n  );\n};\n\nexport default Game;\n","const getScore = coins => {\n  const score = { white: 0, black: 0 };\n  Object.keys(coins).forEach(coin => {\n    if (coins[coin].color === \"white\") score.white++;\n    if (coins[coin].color === \"black\") score.black++;\n  });\n  return score;\n};\n\nexport { getScore };\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Game from \"./components/Game/Game\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<Game />, document.getElementById(\"root\"));\nserviceWorker.register();\n"],"sourceRoot":""}