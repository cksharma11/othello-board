{"version":3,"sources":["components/Coin/Coin.js","engine/rules.js","engine/gameHelper.js","components/Game/Game.js","index.js"],"names":["Coin","color","className","coinNotPlaced","coin","isPlaced","isNextCoinPlacedAndDoesNotHaveSameColor","inPlayColor","isActiveColorCoin","leftSideCoinsValidation","coins","position","replaceableCoins","loopEndCondition","endDistance","Math","floor","getDistanceForLeftSideCoinsValidation","index","push","getReplaceableCoins","inPlayCoin","ceil","rightSideCoinsValidation","round","upsideCoinsValidation","downsideCoinsValidation","leftUpCrossCoinsValidation","rightUpCrossCoinsValidation","leftDownCrossCoinsValidation","rightDownCrossCoinsValidation","getUpdatedBoard","update","forEach","getPossibleMoves","possibleMoves","Object","keys","e","length","isEmptyAndPossibleMove","colors","Game","useState","board","Array","fill","i","createBoard","setBoard","activePlayer","setActivePlayer","setPossibleMoves","useEffect","placeCoin","id","isValidMove","map","initial","createId","onClick","bind","key","includes","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6ee66edb.chunk.js","sourcesContent":["import React from 'react';\n\nconst Coin = ({ color }) => {\n  return <div className={`coin ${color}`}></div>\n};\n\nexport default Coin","const MAX_ROW_COUNT = 8;\nconst MAX_CELL_COUNT = 64;\nconst RIGHT_SIDE_COIN_DIFFERENCE = 7;\nconst LEFT_COIN_DIFFERENCE = 9;\n\nconst coinNotPlaced = (coin) => !coin.isPlaced;\n\nconst isNextCoinPlacedAndDoesNotHaveSameColor = (coin, inPlayColor) => {\n  return coin.isPlaced && coin.color !== inPlayColor;\n}\n\nconst isActiveColorCoin = (coin, inPlayColor) => {\n  return coin.color === inPlayColor;\n}\n\nconst rightSideCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = Math.ceil(position / MAX_ROW_COUNT) * MAX_ROW_COUNT - position;\n  const replaceableCoins = [];\n  for (let index = position + 1; index <= position + endDistance; index++) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst getDistanceForLeftSideCoinsValidation = (position) => {\n  let endDistance = position - Math.floor(position / MAX_ROW_COUNT) * MAX_ROW_COUNT;\n  endDistance = endDistance === 0 ? MAX_ROW_COUNT : endDistance;\n  return endDistance;\n}\n\nconst leftSideCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = getDistanceForLeftSideCoinsValidation(position);\n  const replaceableCoins = [];\n  const loopEndCondition = position - endDistance - 1;\n  for (let index = position - 1; index > loopEndCondition && index > 0; index--) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst upsideCoinsValidation = (coins, position, inPlayColor) => {\n  let endDistance = Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position - MAX_ROW_COUNT; index > 0; index -= MAX_ROW_COUNT) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst downsideCoinsValidation = (coins, position, inPlayColor) => {\n  let endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position + MAX_ROW_COUNT; index <= MAX_CELL_COUNT; index += MAX_ROW_COUNT) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\n\nconst leftUpCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = Math.round(position / MAX_ROW_COUNT) - 1;\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position - LEFT_COIN_DIFFERENCE; index > 0; index -= LEFT_COIN_DIFFERENCE) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst rightUpCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = Math.floor(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position - RIGHT_SIDE_COIN_DIFFERENCE; index > 0; index -= RIGHT_SIDE_COIN_DIFFERENCE) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst leftDownCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position + RIGHT_SIDE_COIN_DIFFERENCE; index <= MAX_CELL_COUNT ; index += RIGHT_SIDE_COIN_DIFFERENCE) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst rightDownCrossCoinsValidation = (coins, position, inPlayColor) => {\n  const endDistance = MAX_ROW_COUNT - Math.round(position / MAX_ROW_COUNT);\n  if (endDistance === 0) return [];\n\n  const replaceableCoins = [];\n  for (let index = position + LEFT_COIN_DIFFERENCE; index <= MAX_CELL_COUNT; index += LEFT_COIN_DIFFERENCE) {\n    if(coinNotPlaced(coins[index])) return [];\n    if (isNextCoinPlacedAndDoesNotHaveSameColor(coins[index], inPlayColor)) {\n      replaceableCoins.push(index);\n    }\n    if (isActiveColorCoin(coins[index], inPlayColor)) {\n      return replaceableCoins;\n    }\n  }\n  return [];\n}\n\nconst getReplaceableCoins = (coins, inPlayCoin, color) => {\n  const inPlayColor = color || inPlayCoin.color;\n  const position = inPlayCoin.position;\n  const replaceableCoins = [\n    ...rightSideCoinsValidation(coins, position, inPlayColor),\n    ...leftSideCoinsValidation(coins, position, inPlayColor),\n    ...upsideCoinsValidation(coins, position, inPlayColor),\n    ...downsideCoinsValidation(coins, position, inPlayColor),\n    ...leftUpCrossCoinsValidation(coins, position, inPlayColor),\n    ...rightUpCrossCoinsValidation(coins, position, inPlayColor),\n    ...leftDownCrossCoinsValidation(coins, position, inPlayColor),\n    ...rightDownCrossCoinsValidation(coins, position, inPlayColor),\n  ];\n  return replaceableCoins;\n}\n\nconst getUpdatedBoard = (coins, inPlayCoin) => {\n  const replaceableCoins = getReplaceableCoins(coins, inPlayCoin);\n\n  const inPlayColor = inPlayCoin.color;\n  const update = { ...coins };\n  replaceableCoins.forEach(index => {\n    update[index].color = inPlayColor === 'black' ? 'black' : 'white';\n  })\n  return update;\n}\n\nconst isValidMove = (coins, inPlayCoin, color) => {\n  if (inPlayCoin.isPlaced) return false;\n  const replaceableCoins = getReplaceableCoins(coins, inPlayCoin, color);\n  return replaceableCoins.length > 0;\n}\n\nconst isEmptyAndPossibleMove = (coins, coin,  color) => {\n  return getReplaceableCoins(coins, coin, color).length && !coin.isPlaced;\n}\n\nconst getPossibleMoves = (coins, color) => {\n  const possibleMoves = [];\n  Object.keys(coins).forEach(e => {\n    if (isEmptyAndPossibleMove(coins, coins[e], color)) {\n      possibleMoves.push(+e);\n    }\n  })\n  return possibleMoves;\n}\n\nexport { \n  getUpdatedBoard, \n  rightSideCoinsValidation, \n  leftSideCoinsValidation, \n  upsideCoinsValidation,\n  downsideCoinsValidation,\n  leftUpCrossCoinsValidation,\n  rightUpCrossCoinsValidation,\n  leftDownCrossCoinsValidation,\n  rightDownCrossCoinsValidation,\n  isValidMove,\n  getPossibleMoves\n};","const createBoard = () => {\n  const board = {}\n  new Array(64).fill(1).forEach((e, i) => {\n      board[i + 1] = {\n        isPlaced: false,\n        color: null,\n        position: i + 1\n      }\n  })\n  board[28].isPlaced = true;\n  board[28].color = \"white\";\n\n  board[29].isPlaced = true;\n  board[29].color = \"black\";\n\n  board[36].isPlaced = true;\n  board[36].color = \"black\";\n\n  board[37].isPlaced = true;\n  board[37].color = \"white\";\n  \n  return board;\n}\n\nconst colors = [\"white\", \"black\"];\n\nconst createId = (initial, i) => initial * 8 + i + 1;\n\nexport { colors, createBoard, createId };","import React, { useState, useEffect } from 'react';\nimport Coin from '../Coin/Coin';\nimport { getUpdatedBoard, isValidMove, getPossibleMoves } from '../../engine/rules';\nimport { createBoard, createId, colors } from '../../engine/gameHelper';\n\nconst Game = () => {\n  const [board, setBoard] = useState(createBoard());\n  const [activePlayer, setActivePlayer] = useState(0);\n  const [possibleMoves, setPossibleMoves] = useState([]);\n\n  useEffect(() => {\n    setPossibleMoves(getPossibleMoves(board, colors[activePlayer]));\n  }, [board, activePlayer]);\n\n  const updateActivePlayer = () => {\n    const update = 1 - activePlayer;\n    setActivePlayer(update);\n  }\n\n  const placeCoin = (id, color) => {\n    const update = { ...board };\n    if (!isValidMove(update, update[id], color)) return;\n\n    update[id] = { ...update[id], isPlaced: true, color };\n    setBoard(update);\n    getUpdatedBoard(update, update[id]);\n    updateActivePlayer();\n  }\n\n  const createRow = (initial) => {\n    return (\n      new Array(8).fill(0).map((e, i) => {\n        const id = createId(initial, i);\n        return (\n          <div\n            onClick={placeCoin.bind(null, id, colors[activePlayer])}\n            id={id}\n            key={id}\n            className={`box `}\n          >\n            {possibleMoves.includes(id) &&<Coin color=\"empty\" /> }\n            {board[id].isPlaced && <Coin color={board[id].color}/> }\n            </div>\n        )\n      })\n    )\n  }\n\n  return (\n    <div className=\"board\">\n      {new Array(8).fill(0).map((e, i) => {\n        return <div className=\"row\">{createRow(i)}</div>\n      })}\n    </div>\n  )\n}\n  \nexport default Game;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport Game from './components/Game/Game';\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}